C51 COMPILER V9.00   BUTTON                                                                06/12/2020 10:50:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE BUTTON
OBJECT MODULE PLACED IN ..\obj\button.obj
COMPILER INVOKED BY: D:\Program Files\KEILC51\files\C51\BIN\C51.EXE ..\..\user\button.c BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\button.lst) TABS(2) OBJECT(..\obj\button.obj)

line level    source

   1          /**
   2            ******************************************************************************
   3            * @file    
   4            * @author  
   5            * @version 
   6            * @date   
   7            * @brief     Support 8 buttons.
   8            ******************************************************************************  
   9            * 
  10            * 
  11            ******************************************************************************
  12            */
  13          /*-- includes ----------------------------------------------------------------*/
  14          #include "./button.h"
  15          #include "./led.h"
  16          
  17          
  18          /*-- defined -----------------------------------------------------------------*/
  19          #define        DB_LOG(x)                  LOG("[BTN]");LOG(x)
  20          #define        TIME_MS(x)                 (x)
  21          
  22          
  23          
  24          #define        IO_BTN1_MODE()               P30_Input_Mode
  25          
  26          
  27          /*< User defined. Max button = 8. 0: not use. >*/
  28          #define        GET_BTN1_STATE()                 P30
  29          #define        GET_BTN2_STATE()                 0
  30          #define        GET_BTN3_STATE()                 0
  31          #define        GET_BTN4_STATE()                 0
  32          #define        GET_BTN5_STATE()                 0
  33          #define        GET_BTN6_STATE()                 0
  34          #define        GET_BTN7_STATE()                 0
  35          #define        GET_BTN8_STATE()                 0
  36          
  37          
  38          
  39          typedef   struct
  40          {
  41            u8_t    currState;
  42            u8_t    lastState;
  43            u8_t    trigDown;
  44            u8_t    trigUp;
  45            u8_t    prevTrig;
  46          }BtnDetectDef;
  47          
  48          
  49          /*-- private variables -------------------------------------------------------*/
  50          static   tick_size_t  XDATA  buttonTaskBaseTr = 0;
  51          
  52          static   BtnDetectDef  XDATA    buttonList;
  53          
  54          
C51 COMPILER V9.00   BUTTON                                                                06/12/2020 10:50:49 PAGE 2   

  55          
  56          /*-- functions ---------------------------------------------------------------*/
  57          static    void    button_task_timer_schedule(void);
  58          static    void    button_task_logic_schedule(void);
  59          
  60          
  61          /**           
  62            * @brief            
  63            * @param    
  64            * @return  
  65            * @note
  66            */ 
  67          static  void  read_button_status(BtnDetectDef* ptBtn, u8_t  buttonArray)
  68          {
  69   1        ptBtn->lastState = ptBtn->currState;
  70   1        ptBtn->currState = buttonArray^0xff;      /* reverse */
  71   1        
  72   1        if(ptBtn->lastState ^ ptBtn->currState)
  73   1        {
  74   2          /* Filt pulse. */
  75   2          return;
  76   2        } 
  77   1        else
  78   1        {
  79   2          ptBtn->trigDown = ptBtn->currState & (ptBtn->currState ^ ptBtn->prevTrig); /* button down, trig once. *
             -/
  80   2          //ptBtn->trigUp = ptBtn->prevTrig & (ptBtn->currState ^ ptBtn->prevTrig);    /* button up, trig once. *
             -/
  81   2          ptBtn->prevTrig = ptBtn->currState;
  82   2        }                            
  83   1      }
  84          
  85          
  86          /**           
  87            * @brief            
  88            * @param    
  89            * @return  
  90            * @note
  91            */
  92          static  void  button_task_timer_schedule(void)
  93          {
  94   1        u8_t XDATA  buttonArray = 0; 
  95   1        u8_t XDATA  ioState = 0;
  96   1      
  97   1        TASK_TIMER_BEGIN(buttonTaskBaseTr, TIME_MS(20));
  98   3      
  99   3        /* Read IO state. */
 100   3        ioState = GET_BTN1_STATE();
 101   3        buttonArray |= (ioState << 0);
 102   3        ioState = GET_BTN2_STATE();
 103   3        buttonArray |= (ioState << 1);
 104   3        ioState = GET_BTN3_STATE();
 105   3        buttonArray |= (ioState << 2);
 106   3        ioState = GET_BTN4_STATE();
 107   3        buttonArray |= (ioState << 3);
 108   3        ioState = GET_BTN5_STATE();
 109   3        buttonArray |= (ioState << 4);
 110   3        ioState = GET_BTN6_STATE();
 111   3        buttonArray |= (ioState << 5);
 112   3        ioState = GET_BTN7_STATE();
 113   3        buttonArray |= (ioState << 6);
 114   3        ioState = GET_BTN8_STATE();
C51 COMPILER V9.00   BUTTON                                                                06/12/2020 10:50:49 PAGE 3   

 115   3        buttonArray |= (ioState << 7);
 116   3        read_button_status(&buttonList, buttonArray);
 117   3      
 118   3        /* Button 1 trig action. */
 119   3        if(buttonList.trigDown & (1<<0)) 
 120   3        {
 121   4          led_write(LED1, LED_TOGGLE);
 122   4          led_write(LED2, LED_OFF);
 123   4          led_write(LED3, LED_OFF);
 124   4          led_write(LED4, LED_OFF);
 125   4        }
 126   3      
 127   3        /* Button 2 trig action. */
 128   3        if(buttonList.trigDown & (1<<1)) 
 129   3        {
 130   4          
 131   4        }
 132   3      
 133   3        /* Button 3 trig action. */
 134   3        if(buttonList.trigDown & (1<<2)) 
 135   3        {
 136   4          
 137   4        }
 138   3      
 139   3        /* Button 4 trig action. */
 140   3        if(buttonList.trigDown & (1<<3)) 
 141   3        {
 142   4          
 143   4        }
 144   3      
 145   3        /* Button 5 trig action. */
 146   3        if(buttonList.trigDown & (1<<4)) 
 147   3        {
 148   4      
 149   4        }
 150   3      
 151   3        /* Button 6 trig action. */
 152   3        if(buttonList.trigDown & (1<<5)) 
 153   3        {
 154   4      
 155   4        }
 156   3      
 157   3        /* Button 7 trig action. */
 158   3        if(buttonList.trigDown & (1<<6)) 
 159   3        {
 160   4      
 161   4        }
 162   3      
 163   3        /* Button 8 trig action. */
 164   3        if(buttonList.trigDown & (1<<7)) 
 165   3        {
 166   4      
 167   4        }
 168   3      
 169   3        TASK_TIMER_END(buttonTaskBaseTr);
 170   1      }
 171          
 172          
 173          /**           
 174            * @brief            
 175            * @param    
 176            * @return  
C51 COMPILER V9.00   BUTTON                                                                06/12/2020 10:50:49 PAGE 4   

 177            * @note
 178            */
 179          static  void  button_task_logic_schedule(void)
 180          {    
 181   1        
 182   1      
 183   1      
 184   1      }
 185          
 186          
 187          /**           
 188            * @brief            
 189            * @param    
 190            * @return  
 191            * @note
 192            */
 193          void   button_task(void)   _task_   BUTTON_TASK_PRIORITY
 194          {  
 195   1        /* Button pin configuration. */
 196   1        IO_BTN1_MODE();
 197   1      
 198   1        while(1)
 199   1        {
 200   2          button_task_timer_schedule();
 201   2          button_task_logic_schedule();
 202   2        }
 203   1      }
 204          
 205          
 206          
 207          
 208          /*---------------------- end of file -----------------------------------------*/
 209          
 210          
 211          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    269    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      6       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
